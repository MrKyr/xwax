#!/bin/sh
#
# Take a pathname as an argument and output a playlist to standard
# output and errors to standard error.
#
# The output format is repeated sequences of:
#
#   <pathname>\t<artist>\t<title>\n
#
# If the tab (\t) or newline (\n) characters appear in a filename,
# unexpected things will happen.

DIR="$1"
EXT=${DIR##*.}

if [ $EXT = "xspf" ]; then
    xsltproc playlist.xsl $DIR | awk '
    BEGIN { RS="" };
    {
        gsub(/file:\/\//, "");
        gsub(/%20/, " ");
        gsub(/%5B/, "[");
        gsub(/%5D/, "]");
        gsub(/%3B/, ";");
        print
    }
' | sed -n '
{
    #title and artist parsed
    s:.\+\t.\+\t.\+$:\0:p
    t

#only title or artist, attempt to parse
#s:^\(.\+\)\t\([0-9]\+.\?[\s_]\+\)\?\(.*\)-\(.*\)\(\.[a-zA-Z0-9]*\)\?$:\1\t\3\t\4:p
s:^\(.\+\)\t\([0-9]\+.\?[\s_]\+\)\?\(.*\)-\(.*\)$:\1\t\3\t\4:p
t

#title seems to be a filename, separate name and extension
s:^\(.\+\)\t\([0-9]\+.\?[\s_]\+\)\?\(.*\)\.\([a-zA-Z0-9]*\)$:\1\t\3\t\4:p
t

#title unknown
s:^\(.\+\)\t\(.\+\)$:\1\t\t\2:p
t

# /[<num>[.]] <artist> - <title>.ext
# for some reason this regex does not parse files with multiple dashes
s:/\([0-9]\+.\?[\s_]\+\)\?\([^/]*\)[\s_]\+-[\s_]\+\([^/]*\)\.[a-zA-Z0-9]*$:\0\t\2\t\3:p
t

# /<artist> - <album>[/Disc <n>.*]/[<num>[.]] <title>.ext
s:/\([^/]*\)[\s_]\+-[\s_]\+\([^/]*\)\(/Disc[\s_][0-9][^/]*\)\?/\([0-9]\+.\?[\s_]\+\)\?\([^/]*\)\.[a-zA-Z0-9]*$:\0\t\1\t\5:p
t

# /[<num>[.]] <name>.ext
s:/\([0-9]\+.\?[\s_]\+\)\?\([^/]*\)\.[a-zA-Z0-9]*$:\0\t\t\2:p
}
'
else
    if [ $EXT = "pls" ]; then
        #todo: check [playlist] header

        #skip the first two lines	
        #treat the entire file as a single record
        #remove all unneeded .PLS lines
        #put Title on the same line as Filename with tab separation
        #if filename is relative, add path (won't always work)
        #strip File and file://
        #replace special characters
        tail -n +3 "$DIR" | awk '
        BEGIN { RS="" };
        {
            gsub(/\n(Length|NumberOfEntries|Version).*\n/, "");
            gsub(/\nTitle/, "\t");
            gsub(/File[0-9]+=[^\/(file)]/, "'$PWD'");
            gsub(/File[0-9]+=file:\/\//, "");
            gsub(/%20/, " ");
            gsub(/%5B/, "[");
            gsub(/%5D/, "]");
            gsub(/%3B/, ";");
            print
        }
    ' | sed -n '
    {
        # <filename>\t[0-1000]=<artist> - <title>
        s:\(.*\)\t[0-9]\+=\(.*\)[\s_]\+-[\s_]\+\(.*\)$:\1\t\2\t\3:p
        t

# /[<num>[.]] <artist> - <title>.ext
s:/\([0-9]\+.\?[\s_]\+\)\?\([^/]*\)[_ ]\+-[_ ]\+\([^/]*\)\.[a-zA-Z0-9]*$:\0\t\2\t\3:p
t

# /<artist> - <album>[/Disc <n>.*]/[<num>[.]] <title>.ext
s:/\([^/]*\)[\s_]\+-[\s_]\+\([^/]*\)\(/Disc[\s_][0-9][^/]*\)\?/\([0-9]\+.\?[\s_]\+\)\?\([^/]*\)\.[a-zA-Z0-9]*$:\0\t\1\t\5:p
t

# /[<num>[.]] <name>.ext
s:/\([0-9]\+.\?[\s_]\+\)\?\([^/]*\)\.[a-zA-Z0-9]*$:\0\t\t\2:p
}
'
else
    if [ $EXT = "pls2" ]; then
        /bin/cat "$DIR"

    else
        FILTER="-iname *.ogg -o -iname *.aac -o -iname *.cdaudio -o -iname *.mp3 -o -iname *.flac -o -iname *.wav -o -iname *.live"
        find "$DIR" $FILTER -type f | sed -n '
        {
            # /[<ABnum>[.]] <artist> - <title>.ext
            s:/\([A-H]\?[A0-9]\?[0-9].\? \+\)\?\([^/]*\) \+- \+\([^/]*\)\.[A-Z0-9]*$:\0\t\2\t\3:pi
            t

             # /<artist> - <album>[/(Disc|Side) <name>]/[<ABnum>[.]] <title>.ext
             s:/\([^/]*\) \+- \+\([^/]*\)\(/\(disc\|side\) [0-9A-Z][^/]*\)\?/\([A-H]\?[A0-9]\?[0-9].\? \+\)\?\([^/]*\)\.[A-Z0-9]*$:\0\t\1\t\6:pi
             t

             # /[<ABnum>[.]] <name>.ext
             s:/\([A-H]\?[A0-9]\?[0-9].\? \+\)\?\([^/]*\)\.[A-Z0-9]*$:\0\t\t\2:pi
         }' |

             # Extract BPM metadata from title (eg. "Ghostbusters (115.6 BPM)")

         sed '
         {
             # BPM
             s:\(.*\) *(\([0-9]\+\.\?[0-9]\+\) *BPM)$:\1\t\2:
         }'
    fi
    fi
fi
